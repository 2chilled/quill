<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Quill : Compile-time Language Integrated Query for Scala">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Quill</title>
  </head>

  <body>
    
    <script>
  ((window.gitter = {}).chat = {}).options = {
    room: 'getquill/quill'
  };
</script>
<script src="https://sidecar.gitter.im/dist/sidecar.v1.js" async defer></script>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/getquill/quill">View on GitHub</a>

          <h1 id="project_title">Quill</h1>
          <h2 id="project_tagline">Compile-time Language Integrated Query for Scala</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/getquill/quill/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/getquill/quill/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <p>Quill provides a Quoted Domain Specific Language (<a href="http://homepages.inf.ed.ac.uk/slindley/papers/qdsl-draft-february2015.pdf">QDSL</a>) to express queries in Scala and execute them in a target language. The library's core is designed to support multiple target languages, currently featuring specializations for Structured Query Language (<a href="https://en.wikipedia.org/wiki/SQL">SQL</a>) and Cassandra Query Language (<a href="https://cassandra.apache.org/doc/cql3/CQL.html#selectStmt">CQL</a>).</p>

<p><img src="https://raw.githubusercontent.com/getquill/quill/master/example.gif" alt="example"></p>

<ol>
<li>
<strong>Boilerplate-free mapping</strong>: The database schema is mapped using simple case classes.</li>
<li>
<strong>Quoted DSL</strong>: Queries are defined inside a <code>quote</code> block. Quill parses each quoted block of code (quotation) at compile time and translates them to an internal Abstract Syntax Tree (AST)</li>
<li>
<strong>Compile-time query generation</strong>: The <code>db.run</code> call reads the quotation's AST and translates it to the target language at compile time, emitting the query string as a compilation message. As the query string is known at compile time, the runtime overhead is very low and similar to using the database driver directly.</li>
<li>
<strong>Compile-time query validation</strong>: If configured, the query is verified against the database at compile time and the compilation fails if it is not valid. The query validation <strong>does not</strong> alter the database state.</li>
</ol>

<h1>
<a id="index" class="anchor" href="#index" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Index</h1>

<ul>
<li><a href="#quotation">Quotation</a></li>
<li><a href="#mirror-sources">Mirror sources</a></li>
<li><a href="#compile-time-quotations">Compile-time quotations</a></li>
<li><a href="#bindings">Bindings</a></li>
<li><a href="#schema">Schema</a></li>
<li><a href="#queries">Queries</a></li>
<li><a href="#query-probing">Query probing</a></li>
<li><a href="#actions">Actions</a></li>
<li><a href="#dynamic-queries">Dynamic queries</a></li>
<li><a href="#sql-specific-operations">SQL-specific operations</a></li>
<li><a href="#cassandra-specific-operations">Cassandra-specific operations</a></li>
<li>
<a href="#extending-quill">Extending quill</a>

<ul>
<li><a href="#infix">Infix</a></li>
<li><a href="#custom-encoding">Custom encoding</a></li>
</ul>
</li>
<li>
<a href="#sql-sources">Sql Sources</a>

<ul>
<li><a href="#dialect">Dialect</a></li>
<li><a href="#naming-strategy">Naming strategy</a></li>
<li><a href="#configuration">Configuration</a></li>
</ul>
</li>
<li><a href="#cassandra-sources">Cassandra sources</a></li>
<li><a href="#templates">Templates</a></li>
<li><a href="#acknowledgments">Acknowledgments</a></li>
<li><a href="#code-of-conduct">Code of Conduct</a></li>
<li><a href="#license">License</a></li>
</ul>

<h1>
<a id="quotation" class="anchor" href="#quotation" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Quotation</h1>

<p>The QDSL allows the user to write plain Scala code, leveraging scala's syntax and type system. Quotations are created using the <code>quote</code> method and can contain any excerpt of code that uses supported operations. To create quotations, first import <code>quote</code> and some other auxiliary methods:</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">import</span> <span class="pl-v">io.getquill.</span><span class="pl-v">_</span></pre></div>

<p>A quotation can be a simple value:</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">pi</span> <span class="pl-k">=</span> quote(<span class="pl-c1">3.14159</span>)</pre></div>

<p>And be used within another quotation:</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Circle</span>(<span class="pl-v">radius</span>: <span class="pl-k">Float</span>)

<span class="pl-k">val</span> <span class="pl-en">areas</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Circle</span>].map(c <span class="pl-k">=&gt;</span> pi <span class="pl-k">*</span> c.radius <span class="pl-k">*</span> c.radius)
}</pre></div>

<p>Quotations can also contain high-order functions and inline values:</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">area</span> <span class="pl-k">=</span> quote {
  (<span class="pl-v">c</span>: <span class="pl-en">Circle</span>) <span class="pl-k">=&gt;</span> {
    <span class="pl-k">val</span> <span class="pl-en">r2</span> <span class="pl-k">=</span> c.radius <span class="pl-k">*</span> c.radius
    pi <span class="pl-k">*</span> r2
  }
}</pre></div>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">areas</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Circle</span>].map(c <span class="pl-k">=&gt;</span> area(c))
}</pre></div>

<p>Quotations can contain values defined outside of the quotation:</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">pi</span> <span class="pl-k">=</span> <span class="pl-c1">3.14159</span>
<span class="pl-k">val</span> <span class="pl-en">areas</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Circle</span>].map(c <span class="pl-k">=&gt;</span> pi <span class="pl-k">*</span> c.radius <span class="pl-k">*</span> c.radius)
}</pre></div>

<p>Quill's normalization engine applies reduction steps before translating the quotation to the target language. The correspondent normalized quotation for both versions of the <code>areas</code> query is:</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">areas</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Circle</span>].map(c <span class="pl-k">=&gt;</span> <span class="pl-c1">3.14159</span> <span class="pl-k">*</span> c.radius <span class="pl-k">*</span> c.radius)
}</pre></div>

<p>Scala doesn't have support for high-order functions with type parameters. Quill supports anonymous classes with an apply method for this purpose:</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">existsAny</span> <span class="pl-k">=</span> quote {
  new {
    <span class="pl-k">def</span> <span class="pl-en">apply</span>[<span class="pl-en">T</span>](<span class="pl-v">xs</span>: <span class="pl-en">Query</span>[<span class="pl-en">T</span>])(<span class="pl-v">p</span>: <span class="pl-en">T</span> <span class="pl-k">=&gt;</span> <span class="pl-k">Boolean</span>) <span class="pl-k">=</span>
        xs.filter(p(_)).nonEmpty
  }
}

<span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Circle</span>].filter { c1 <span class="pl-k">=&gt;</span> 
    existsAny(query[<span class="pl-en">Circle</span>])(c2 <span class="pl-k">=&gt;</span> c2.radius <span class="pl-k">&gt;</span> c1.radius)
  }
}</pre></div>

<h1>
<a id="mirror-sources" class="anchor" href="#mirror-sources" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Mirror sources</h1>

<p>Sources represent the database and provide an execution interface for queries. Quill provides mirror sources for test purposes. Please refer to <a href="#sources">sources</a> for information on how to create normal sources.</p>

<p>Instead of running the query, mirror sources return a structure with the information that would be used to run the query. There are three mirror source configurations:</p>

<ul>
<li>
<code>io.getquill.MirrorSourceConfig</code>: Mirrors the quotation AST</li>
<li>
<code>io.getquill.SqlMirrorSourceConfig</code>: Mirrors the SQL query</li>
<li>
<code>io.getquill.CassandraMirrorSourceConfig</code>: Mirrors the CQL query</li>
</ul>

<p>This documentation uses the SQL mirror in its examples under the <code>db</code> name:</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">import</span> <span class="pl-v">io.getquill.</span><span class="pl-v">_</span>

<span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">db</span> <span class="pl-k">=</span> source(<span class="pl-k">new</span> <span class="pl-en">SqlMirrorSourceConfig</span>(<span class="pl-s"><span class="pl-pds">"</span>testSource<span class="pl-pds">"</span></span>))</pre></div>

<h1>
<a id="compile-time-quotations" class="anchor" href="#compile-time-quotations" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Compile-time quotations</h1>

<p>Quotations are both compile-time and runtime values. Quill uses a type refinement to store the quotation's AST as an annotation available at compile-time and the <code>q.ast</code> method exposes the AST as runtime value.</p>

<p>It is important to avoid giving explicit types to quotations when possible. For instance, this quotation can't be read at compile-time as the type refinement is lost:</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-c">// Avoid type widening (Quoted[Query[Circle]]), or else the quotation will be dynamic.</span>
<span class="pl-k">val</span> <span class="pl-en">q</span><span class="pl-k">:</span> <span class="pl-en">Quoted</span>[<span class="pl-en">Query</span>[<span class="pl-en">Circle</span>]] <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Circle</span>].filter(c <span class="pl-k">=&gt;</span> c.radius <span class="pl-k">&gt;</span> <span class="pl-c1">10</span>)
}

db.run(q) <span class="pl-c">// Dynamic query</span></pre></div>

<p>Quill falls back to runtime normalization and query generation if the quotation's AST can be read at compile-time. Please refer to <a href="#dynamic-queries">dynamic queries</a> for more information</p>

<h1>
<a id="bindings" class="anchor" href="#bindings" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Bindings</h1>

<p>Quotations are designed to be self-contained, without references to runtime values outside their scope. There are two mechanisms to explicitly bind runtime values to a quotation execution.</p>

<h2>
<a id="lifted-values" class="anchor" href="#lifted-values" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Lifted values</h2>

<p>A runtime value can be lifted to a quotation through the method <code>lift</code>:</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">def</span> <span class="pl-en">biggerThan</span>(<span class="pl-v">i</span>: <span class="pl-k">Float</span>) <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Circle</span>].filter(r <span class="pl-k">=&gt;</span> r.radius <span class="pl-k">&gt;</span> lift(i))
}
db.run(biggerThan(<span class="pl-c1">10</span>)) <span class="pl-c">// SELECT r.radius FROM Circle r WHERE r.radius &gt; ?</span></pre></div>

<h2>
<a id="parametrized-quotations" class="anchor" href="#parametrized-quotations" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Parametrized quotations</h2>

<p>A quotation can be defined as a function:</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">biggerThan</span> <span class="pl-k">=</span> quote {
  (<span class="pl-v">i</span>: <span class="pl-k">Int</span>) <span class="pl-k">=&gt;</span>
    query[<span class="pl-en">Circle</span>].filter(r <span class="pl-k">=&gt;</span> r.radius <span class="pl-k">&gt;</span> i)
}</pre></div>

<p>And a runtime value can be specified when running it:</p>

<div class="highlight highlight-source-scala"><pre>db.run(biggerThan)(<span class="pl-c1">10</span>) <span class="pl-c">// SELECT r.radius FROM Circle r WHERE r.radius &gt; ?</span></pre></div>

<h1>
<a id="schema" class="anchor" href="#schema" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Schema</h1>

<p>The database schema is represented by case classes. By default, quill uses the class and field names as the database identifiers:</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Circle</span>(<span class="pl-v">radius</span>: <span class="pl-k">Float</span>)

<span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Circle</span>].filter(c <span class="pl-k">=&gt;</span> c.radius <span class="pl-k">&gt;</span> <span class="pl-c1">1</span>)
}

db.run(q) <span class="pl-c">// SELECT c.radius FROM Circle c WHERE c.radius &gt; 1</span></pre></div>

<p>Alternatively, the identifiers can be customized:</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">circles</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Circle</span>].schema(_.entity(<span class="pl-s"><span class="pl-pds">"</span>circle_table<span class="pl-pds">"</span></span>).columns(_.radius <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>radius_column<span class="pl-pds">"</span></span>))
}

<span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  circles.filter(c <span class="pl-k">=&gt;</span> c.radius <span class="pl-k">&gt;</span> <span class="pl-c1">1</span>)
}

db.run(q) 
<span class="pl-c">// SELECT c.radius_column FROM circle_table c WHERE c.radius_column &gt; 1</span></pre></div>

<p>If multiple tables require custom identifiers, it is good practice to define a <code>schema</code> object with all table queries to be reused across multiple queries:</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Circle</span>(<span class="pl-v">radius</span>: <span class="pl-k">Int</span>)
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Rectangle</span>(<span class="pl-v">length</span>: <span class="pl-k">Int</span>, <span class="pl-v">width</span>: <span class="pl-k">Int</span>)
<span class="pl-k">object</span> <span class="pl-en">schema</span> {
  <span class="pl-k">val</span> <span class="pl-en">circles</span> <span class="pl-k">=</span> quote {
    query[<span class="pl-en">Circle</span>].schema(
        _.entity(<span class="pl-s"><span class="pl-pds">"</span>circle_table<span class="pl-pds">"</span></span>)
        .columns(_.radius <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>radius_column<span class="pl-pds">"</span></span>))
  }
  <span class="pl-k">val</span> <span class="pl-en">rectangles</span> <span class="pl-k">=</span> quote {
    query[<span class="pl-en">Rectangle</span>].schema(
        _.entity(<span class="pl-s"><span class="pl-pds">"</span>rectangle_table<span class="pl-pds">"</span></span>)
        .columns(
          _.length <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>length_column<span class="pl-pds">"</span></span>,
          _.width <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>width_column<span class="pl-pds">"</span></span>))
  }
}</pre></div>

<p>It is possible to define a column that is a key generated by the database. It will be ignored during insertions and returned as the result.
Note that it accepts only values that can be read as <code>Long</code>.</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Product</span>(<span class="pl-v">id</span>: <span class="pl-k">Long</span>, <span class="pl-v">description</span>: <span class="pl-k">String</span>, <span class="pl-v">sku</span>: <span class="pl-k">Long</span>)

<span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Product</span>].schema(_.generated(_.id)).insert
}

db.run(q)
<span class="pl-c">// INSERT INTO Product (description,sku) VALUES (?, ?)</span></pre></div>

<h1>
<a id="queries" class="anchor" href="#queries" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Queries</h1>

<p>The overall abstraction of quill queries is use database tables as if they were in-memory collections. Scala for-comprehensions provide syntatic sugar to deal with this kind of monadic operations:</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Person</span>(<span class="pl-v">id</span>: <span class="pl-k">Int</span>, <span class="pl-v">name</span>: <span class="pl-k">String</span>, <span class="pl-v">age</span>: <span class="pl-k">Int</span>)
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Contact</span>(<span class="pl-v">personId</span>: <span class="pl-k">Int</span>, <span class="pl-v">phone</span>: <span class="pl-k">String</span>)

<span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  <span class="pl-k">for</span> {
    p <span class="pl-k">&lt;</span><span class="pl-k">-</span> query[<span class="pl-en">Person</span>] <span class="pl-k">if</span>(p.id <span class="pl-k">==</span> <span class="pl-c1">999</span>)
    c <span class="pl-k">&lt;</span><span class="pl-k">-</span> query[<span class="pl-en">Contact</span>] <span class="pl-k">if</span>(c.personId <span class="pl-k">==</span> p.id)
  } <span class="pl-k">yield</span> {
    (p.name, c.phone)
  }
}

db.run(q) 
<span class="pl-c">// SELECT p.name, c.phone FROM Person p, Contact c WHERE (p.id = 999) AND (c.personId = p.id)</span></pre></div>

<p>Quill normalizes the quotation and translates the monadic joins to applicative joins, generating a database-friendly query that avoids nested queries.</p>

<p>Any of the following features can be used together with the others and/or within a for-comprehension:</p>

<p><strong>filter</strong></p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].filter(p <span class="pl-k">=&gt;</span> p.age <span class="pl-k">&gt;</span> <span class="pl-c1">18</span>)
}

db.run(q)
<span class="pl-c">// SELECT p.id, p.name, p.age FROM Person p WHERE p.age &gt; 18</span></pre></div>

<p><strong>map</strong></p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].map(p <span class="pl-k">=&gt;</span> p.name)
}

db.run(q)
<span class="pl-c">// SELECT p.name FROM Person p</span></pre></div>

<p><strong>flatMap</strong></p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].filter(p <span class="pl-k">=&gt;</span> p.age <span class="pl-k">&gt;</span> <span class="pl-c1">18</span>).flatMap(p <span class="pl-k">=&gt;</span> query[<span class="pl-en">Contact</span>].filter(c <span class="pl-k">=&gt;</span> c.personId <span class="pl-k">==</span> p.id))
}

db.run(q)
<span class="pl-c">// SELECT c.personId, c.phone FROM Person p, Contact c WHERE (p.age &gt; 18) AND (c.personId = p.id)</span></pre></div>

<p><strong>sortBy</strong></p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">q1</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].sortBy(p <span class="pl-k">=&gt;</span> p.age)
}

db.run(q1)
<span class="pl-c">// SELECT p.id, p.name, p.age FROM Person p ORDER BY p.age ASC NULLS FIRST</span>

<span class="pl-k">val</span> <span class="pl-en">q2</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].sortBy(p <span class="pl-k">=&gt;</span> p.age)(<span class="pl-en">Ord</span>.descNullsLast)
}

db.run(q2)
<span class="pl-c">// SELECT p.id, p.name, p.age FROM Person p ORDER BY p.age DESC NULLS LAST</span>

<span class="pl-k">val</span> <span class="pl-en">q3</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].sortBy(p <span class="pl-k">=&gt;</span> (p.name, p.age))(<span class="pl-en">Ord</span>(<span class="pl-en">Ord</span>.asc, <span class="pl-en">Ord</span>.desc))
}

db.run(q3)
<span class="pl-c">// SELECT p.id, p.name, p.age FROM Person p ORDER BY p.name ASC, p.age DESC</span></pre></div>

<p><strong>drop/take</strong></p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].drop(<span class="pl-c1">2</span>).take(<span class="pl-c1">1</span>)
}

db.run(q)
<span class="pl-c">// SELECT x.id, x.name, x.age FROM Person x LIMIT 1 OFFSET 2</span></pre></div>

<p><strong>groupBy</strong></p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].groupBy(p <span class="pl-k">=&gt;</span> p.age).map {
    <span class="pl-k">case</span> (age, people) <span class="pl-k">=&gt;</span>
      (age, people.size)
  }
}

db.run(q)
<span class="pl-c">// SELECT p.age, COUNT(*) FROM Person p GROUP BY p.age</span></pre></div>

<p><strong>union</strong></p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].filter(p <span class="pl-k">=&gt;</span> p.age <span class="pl-k">&gt;</span> <span class="pl-c1">18</span>).union(query[<span class="pl-en">Person</span>].filter(p <span class="pl-k">=&gt;</span> p.age <span class="pl-k">&gt;</span> <span class="pl-c1">60</span>))
}

db.run(q)
<span class="pl-c">// SELECT x.id, x.name, x.age FROM (SELECT id, name, age FROM Person p WHERE p.age &gt; 18 </span>
<span class="pl-c">// UNION SELECT id, name, age FROM Person p1 WHERE p1.age &gt; 60) x</span></pre></div>

<p><strong>unionAll/++</strong></p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].filter(p <span class="pl-k">=&gt;</span> p.age <span class="pl-k">&gt;</span> <span class="pl-c1">18</span>).unionAll(query[<span class="pl-en">Person</span>].filter(p <span class="pl-k">=&gt;</span> p.age <span class="pl-k">&gt;</span> <span class="pl-c1">60</span>))
}

db.run(q) 
<span class="pl-c">// SELECT x.id, x.name, x.age FROM (SELECT id, name, age FROM Person p WHERE p.age &gt; 18 </span>
<span class="pl-c">// UNION ALL SELECT id, name, age FROM Person p1 WHERE p1.age &gt; 60) x</span>

<span class="pl-k">val</span> <span class="pl-en">q2</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].filter(p <span class="pl-k">=&gt;</span> p.age <span class="pl-k">&gt;</span> <span class="pl-c1">18</span>) <span class="pl-k">++</span> query[<span class="pl-en">Person</span>].filter(p <span class="pl-k">=&gt;</span> p.age <span class="pl-k">&gt;</span> <span class="pl-c1">60</span>)
}

db.run(q2) 
<span class="pl-c">// SELECT x.id, x.name, x.age FROM (SELECT id, name, age FROM Person p WHERE p.age &gt; 18 </span>
<span class="pl-c">// UNION ALL SELECT id, name, age FROM Person p1 WHERE p1.age &gt; 60) x</span></pre></div>

<p><strong>aggregation</strong></p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">r</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].map(p <span class="pl-k">=&gt;</span> p.age)
}

db.run(r.min) <span class="pl-c">// SELECT MIN(p.age) FROM Person p</span>
db.run(r.max) <span class="pl-c">// SELECT MAX(p.age) FROM Person p</span>
db.run(r.avg) <span class="pl-c">// SELECT AVG(p.age) FROM Person p</span>
db.run(r.sum) <span class="pl-c">// SELECT SUM(p.age) FROM Person p</span>
db.run(r.size) <span class="pl-c">// SELECT COUNT(p.age) FROM Person p</span></pre></div>

<p><strong>isEmpty/nonEmpty</strong></p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].filter{ p1 <span class="pl-k">=&gt;</span> 
    query[<span class="pl-en">Person</span>].filter(p2 <span class="pl-k">=&gt;</span> p2.id <span class="pl-k">!=</span> p1.id <span class="pl-k">&amp;&amp;</span> p2.age <span class="pl-k">==</span> p1.age).isEmpty
  }
}

db.run(q) 
<span class="pl-c">// SELECT p1.id, p1.name, p1.age FROM Person p1 WHERE </span>
<span class="pl-c">// NOT EXISTS (SELECT * FROM Person p2 WHERE (p2.id &lt;&gt; p1.id) AND (p2.age = p1.age))</span>

<span class="pl-k">val</span> <span class="pl-en">q2</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].filter{ p1 <span class="pl-k">=&gt;</span> 
    query[<span class="pl-en">Person</span>].filter(p2 <span class="pl-k">=&gt;</span> p2.id <span class="pl-k">!=</span> p1.id <span class="pl-k">&amp;&amp;</span> p2.age <span class="pl-k">==</span> p1.age).nonEmpty
  }
}

db.run(q2)
<span class="pl-c">// SELECT p1.id, p1.name, p1.age FROM Person p1 WHERE </span>
<span class="pl-c">// EXISTS (SELECT * FROM Person p2 WHERE (p2.id &lt;&gt; p1.id) AND (p2.age = p1.age))</span></pre></div>

<p><strong>contains</strong></p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].filter(p <span class="pl-k">=&gt;</span> <span class="pl-en">Set</span>(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>).contains(p.id))
}

db.run(q)
<span class="pl-c">// SELECT p.id, p.name, p.age FROM Person p WHERE p.id IN (1, 2)</span>

<span class="pl-k">val</span> <span class="pl-en">q1</span> <span class="pl-k">=</span> quote { (<span class="pl-v">ids</span>: <span class="pl-en">Set</span>[<span class="pl-k">Int</span>]) <span class="pl-k">=&gt;</span>
  query[<span class="pl-en">Person</span>].filter(p <span class="pl-k">=&gt;</span> ids.contains(p.id))
}

db.run(q1)
<span class="pl-c">// SELECT p.id, p.name, p.age FROM Person p WHERE p.id IN (?)</span>

<span class="pl-k">val</span> <span class="pl-en">peopleWithContacts</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].filter(p <span class="pl-k">=&gt;</span> query[<span class="pl-en">Contact</span>].filter(c <span class="pl-k">=&gt;</span> c.personId <span class="pl-k">==</span> p.id).nonEmpty)
}
<span class="pl-k">val</span> <span class="pl-en">q2</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].filter(p <span class="pl-k">=&gt;</span> peopleWithContacts.contains(p.id))
}

db.run(q2)
<span class="pl-c">// SELECT p.id, p.name, p.age FROM Person p WHERE p.id IN (SELECT p1.* FROM Person p1 WHERE EXISTS (SELECT c.* FROM Contact c WHERE c.personId = p1.id))</span></pre></div>

<p><strong>distinct</strong></p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].map(p <span class="pl-k">=&gt;</span> p.age).distinct
}

db.run(q)
<span class="pl-c">// SELECT DISTINCT p.age FROM Person p</span></pre></div>

<p><strong>joins</strong></p>

<p>In addition to applicative joins Quill also supports explicit joins (both inner and left/right/full outer joins).</p>

<div class="highlight highlight-source-scala"><pre>
<span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].join(query[<span class="pl-en">Contact</span>]).on((p, c) <span class="pl-k">=&gt;</span> c.personId <span class="pl-k">==</span> p.id)
}

db.run(q) 
<span class="pl-c">// SELECT p.id, p.name, p.age, c.personId, c.phone•</span>
<span class="pl-c">// FROM Person p INNER JOIN Contact c ON c.personId = p.id</span>

<span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].leftJoin(query[<span class="pl-en">Contact</span>]).on((p, c) <span class="pl-k">=&gt;</span> c.personId <span class="pl-k">==</span> p.id)
}

db.run(q) 
<span class="pl-c">// SELECT p.id, p.name, p.age, c.personId, c.phone•</span>
<span class="pl-c">// FROM Person p LEFT JOIN Contact c ON c.personId = p.id</span>
</pre></div>

<p>The example joins above cover the simple case. What do you do when a query requires joining more than 2 tables?</p>

<p>With Quill the following multi-join queries are equivalent, choose according to preference:</p>

<div class="highlight highlight-source-scala"><pre>
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Employer</span>(<span class="pl-v">id</span>: <span class="pl-k">Int</span>, <span class="pl-v">personId</span>: <span class="pl-k">Int</span>, <span class="pl-v">name</span>: <span class="pl-k">String</span>)

<span class="pl-k">val</span> <span class="pl-en">qFlat</span> <span class="pl-k">=</span> quote {
  <span class="pl-k">for</span>{
    (p,e) <span class="pl-k">&lt;</span><span class="pl-k">-</span> query[<span class="pl-en">Person</span>].join(query[<span class="pl-en">Employer</span>]).on(_.id <span class="pl-k">==</span> _.personId)
       c  <span class="pl-k">&lt;</span><span class="pl-k">-</span> query[<span class="pl-en">Contact</span>].leftJoin(_.personId <span class="pl-k">==</span> p.id)
  } <span class="pl-k">yield</span>(p, e, c)
}

<span class="pl-k">val</span> <span class="pl-en">qNested</span> <span class="pl-k">=</span> quote {
  <span class="pl-k">for</span>{
    ((p,e),c) <span class="pl-k">&lt;</span><span class="pl-k">-</span>
      query[<span class="pl-en">Person</span>].join(query[<span class="pl-en">Employer</span>]).on(_.id <span class="pl-k">==</span> _.personId)
      .leftJoin(query[<span class="pl-en">Contact</span>]).on(
        _._1.id <span class="pl-k">==</span> _.personId
      )
  } <span class="pl-k">yield</span>(p, e, c)
}

db.run(qFlat) 
db.run(qNested) 
<span class="pl-c">// SELECT p.id, p.name, p.age, e.id, e.personId, e.name, c.id, c.phone•</span>
<span class="pl-c">// FROM Person p INNER JOIN Employer e ON p.id = e.personId LEFT JOIN Contact c ON c.personId = p.id</span>
</pre></div>

<h1>
<a id="query-probing" class="anchor" href="#query-probing" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Query probing</h1>

<p>Query probing is an experimental feature that validates queries against the database at compile time, failing the compilation if it is not valid. The query validation does not alter the database state.</p>

<p>This feature is disabled by default. To enable it, mix the <code>QueryProbing</code> trait to the database configuration:</p>

<pre><code>lazy val db = source(new MySourceConfig("configKey") with QueryProbing)
</code></pre>

<p>The config configuration must be self-contained, not having references to variables outside its scope. This allows the macro load the source instance at compile-time.</p>

<p>The configurations correspondent to the config key must be available at compile time. You can achieve it by adding this line to your project settings:</p>

<pre><code>unmanagedClasspath in Compile += baseDirectory.value / "src" / "main" / "resources"
</code></pre>

<p>If your project doesn't have a standard layout, e.g. a play project, you should configure the path to point to the folder that contains your config file. </p>

<h1>
<a id="actions" class="anchor" href="#actions" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Actions</h1>

<p>Database actions are defined using quotations as well. These actions don't have a collection-like API but rather a custom DSL to express inserts, deletes and updates.</p>

<p>Note: Actions take either a List (in which case the query is batched) or a single value.</p>

<p><strong>insert</strong></p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">a</span> <span class="pl-k">=</span> quote(query[<span class="pl-en">Contact</span>].insert)

db.run(a)(<span class="pl-en">List</span>(<span class="pl-en">Contact</span>(<span class="pl-c1">999</span>, <span class="pl-s"><span class="pl-pds">"</span>+1510488988<span class="pl-pds">"</span></span>))) 
<span class="pl-c">// INSERT INTO Contact (personId,phone) VALUES (?, ?)</span>
db.run(a)(<span class="pl-en">Contact</span>(<span class="pl-c1">999</span>, <span class="pl-s"><span class="pl-pds">"</span>+1510488988<span class="pl-pds">"</span></span>))
<span class="pl-c">// insert single item</span></pre></div>

<p>It is also possible to insert specific columns:</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">a</span> <span class="pl-k">=</span> quote {
  (<span class="pl-v">personId</span>: <span class="pl-k">Int</span>, <span class="pl-v">phone</span>: <span class="pl-k">String</span>) <span class="pl-k">=&gt;</span>
    query[<span class="pl-en">Contact</span>].insert(_.personId <span class="pl-k">-</span><span class="pl-k">&gt;</span> personId, _.phone <span class="pl-k">-</span><span class="pl-k">&gt;</span> phone)
}

db.run(a)(<span class="pl-en">List</span>((<span class="pl-c1">999</span>, <span class="pl-s"><span class="pl-pds">"</span>+1510488988<span class="pl-pds">"</span></span>))) 
<span class="pl-c">// INSERT INTO Contact (personId,phone) VALUES (?, ?)</span></pre></div>

<p>Or column queries:</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">a</span> <span class="pl-k">=</span> quote {
  (<span class="pl-v">id</span>: <span class="pl-k">Int</span>) <span class="pl-k">=&gt;</span>
    query[<span class="pl-en">Person</span>].insert(_.id <span class="pl-k">-</span><span class="pl-k">&gt;</span> id, _.age <span class="pl-k">-</span><span class="pl-k">&gt;</span> query[<span class="pl-en">Person</span>].map(p <span class="pl-k">=&gt;</span> p.age).max)
}

db.run(a)(<span class="pl-en">List</span>(<span class="pl-c1">999</span>)) 
<span class="pl-c">// INSERT INTO Person (id,age) VALUES (?, (SELECT MAX(p.age) FROM Person p))</span></pre></div>

<p><strong>update</strong></p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">a</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].filter(_.id <span class="pl-k">==</span> <span class="pl-c1">999</span>).update
}

db.run(a)(<span class="pl-en">List</span>(<span class="pl-en">Person</span>(<span class="pl-c1">999</span>, <span class="pl-s"><span class="pl-pds">"</span>John<span class="pl-pds">"</span></span>, <span class="pl-c1">22</span>)))
<span class="pl-c">// UPDATE Person SET id = ?, name = ?, age = ? WHERE id = 999</span>
db.run(a)(<span class="pl-en">Person</span>(<span class="pl-c1">999</span>, <span class="pl-s"><span class="pl-pds">"</span>John<span class="pl-pds">"</span></span>, <span class="pl-c1">22</span>))
<span class="pl-c">// update single item</span></pre></div>

<p>Using specific columns:</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">a</span> <span class="pl-k">=</span> quote {
  (<span class="pl-v">id</span>: <span class="pl-k">Int</span>, <span class="pl-v">age</span>: <span class="pl-k">Int</span>) <span class="pl-k">=&gt;</span>
    query[<span class="pl-en">Person</span>].filter(p <span class="pl-k">=&gt;</span> p.id <span class="pl-k">==</span> id).update(_.age <span class="pl-k">-</span><span class="pl-k">&gt;</span> age)
}

db.run(a)(<span class="pl-en">List</span>((<span class="pl-c1">999</span>, <span class="pl-c1">18</span>)))
<span class="pl-c">// UPDATE Person SET age = ? WHERE id = ?</span></pre></div>

<p>Using columns as part of the update:</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">a</span> <span class="pl-k">=</span> quote {
  (<span class="pl-v">id</span>: <span class="pl-k">Int</span>) <span class="pl-k">=&gt;</span>
    query[<span class="pl-en">Person</span>].filter(p <span class="pl-k">=&gt;</span> p.id <span class="pl-k">==</span> id).update(p <span class="pl-k">=&gt;</span> p.age <span class="pl-k">-</span><span class="pl-k">&gt;</span> (p.age <span class="pl-k">+</span> <span class="pl-c1">1</span>))
}

db.run(a)(<span class="pl-en">List</span>(<span class="pl-c1">999</span>))
<span class="pl-c">// UPDATE Person SET age = (age + 1) WHERE id = ?</span></pre></div>

<p>Using column a query:</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">a</span> <span class="pl-k">=</span> quote {
  (<span class="pl-v">id</span>: <span class="pl-k">Int</span>) <span class="pl-k">=&gt;</span>
    query[<span class="pl-en">Person</span>].filter(p <span class="pl-k">=&gt;</span> p.id <span class="pl-k">==</span> id).update(_.age <span class="pl-k">-</span><span class="pl-k">&gt;</span> query[<span class="pl-en">Person</span>].map(p <span class="pl-k">=&gt;</span> p.age).max)
}

db.run(a)(<span class="pl-en">List</span>(<span class="pl-c1">999</span>))
<span class="pl-c">// UPDATE Person SET age = (SELECT MAX(p.age) FROM Person p) WHERE id = ?</span></pre></div>

<p><strong>delete</strong></p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">a</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].filter(p <span class="pl-k">=&gt;</span> p.name <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>).delete
}

db.run(a) 
<span class="pl-c">// DELETE FROM Person WHERE name = ''</span></pre></div>

<h1>
<a id="implicit-query" class="anchor" href="#implicit-query" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Implicit query</h1>

<p>Quill provides implicit conversions from case class companion objects to <code>query[T]</code> through an extra import:</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">import</span> <span class="pl-v">io.getquill.ImplicitQuery.</span><span class="pl-v">_</span>

<span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  <span class="pl-k">for</span> {
    p <span class="pl-k">&lt;</span><span class="pl-k">-</span> <span class="pl-en">Person</span> <span class="pl-k">if</span>(p.id <span class="pl-k">==</span> <span class="pl-c1">999</span>)
    c <span class="pl-k">&lt;</span><span class="pl-k">-</span> <span class="pl-en">Contact</span> <span class="pl-k">if</span>(c.personId <span class="pl-k">==</span> p.id)
  } <span class="pl-k">yield</span> {
    (p.name, c.phone)
  }
}

db.run(q) 
<span class="pl-c">// SELECT p.name, c.phone FROM Person p, Contact c WHERE (p.id = 999) AND (c.personId = p.id)</span></pre></div>

<p>Note the usage of <code>Person</code> and <code>Contact</code> instead of <code>query[Person]</code> and <code>query[Contact]</code>.</p>

<h1>
<a id="sql-specific-operations" class="anchor" href="#sql-specific-operations" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>SQL-specific operations</h1>

<p>Some operations are sql-specific and not provided with the generic quotation mechanism. The <code>io.getquill.sources.sql.ops</code> package has some implicit classes for this kind of operations:</p>

<p><strong>like</strong></p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">import</span> <span class="pl-v">io.getquill.sources.sql.ops.</span><span class="pl-v">_</span>

<span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].filter(p <span class="pl-k">=&gt;</span> p.name like <span class="pl-s"><span class="pl-pds">"</span>%John%<span class="pl-pds">"</span></span>)
}
db.run(q)
<span class="pl-c">// SELECT p.id, p.name, p.age FROM Person p WHERE p.name like '%John%'</span></pre></div>

<h1>
<a id="cassandra-specific-operations" class="anchor" href="#cassandra-specific-operations" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Cassandra-specific operations</h1>

<p>The cql-specific operations are provided by the following import:</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">import</span> <span class="pl-v">io.getquill.sources.cassandra.ops.</span><span class="pl-v">_</span></pre></div>

<p>The cassandra package also offers a mirror source:</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">import</span> <span class="pl-v">io.getquill.</span><span class="pl-v">_</span>

<span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">db</span> <span class="pl-k">=</span> source(<span class="pl-k">new</span> <span class="pl-en">CassandraMirrorSourceConfig</span>(<span class="pl-s"><span class="pl-pds">"</span>testSource<span class="pl-pds">"</span></span>))</pre></div>

<p>Supported operations:</p>

<p><strong>allowFiltering</strong></p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].filter(p <span class="pl-k">=&gt;</span> p.age <span class="pl-k">&gt;</span> <span class="pl-c1">10</span>).allowFiltering
}
db.run(q)
<span class="pl-c">// SELECT id, name, age FROM Person WHERE age &gt; 10 ALLOW FILTERING</span></pre></div>

<p><strong>ifNotExists</strong></p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].insert(_.age <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-c1">10</span>, _.name <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>John<span class="pl-pds">"</span></span>).ifNotExists
}
db.run(q)
<span class="pl-c">// INSERT INTO Person (age,name) VALUES (10, 'John') IF NOT EXISTS</span></pre></div>

<p><strong>ifExists</strong></p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].filter(p <span class="pl-k">=&gt;</span> p.name <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>John<span class="pl-pds">"</span></span>).delete.ifExists
}
db.run(q)
<span class="pl-c">// DELETE FROM Person WHERE name = 'John' IF EXISTS</span></pre></div>

<p><strong>usingTimestamp</strong></p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">q1</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].insert(_.age <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-c1">10</span>, _.name <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>John<span class="pl-pds">"</span></span>).usingTimestamp(<span class="pl-c1">99</span>)
}
db.run(q1)
<span class="pl-c">// INSERT INTO Person (age,name) VALUES (10, 'John') USING TIMESTAMP 99</span>

<span class="pl-k">val</span> <span class="pl-en">q2</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].usingTimestamp(<span class="pl-c1">99</span>).update(_.age <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-c1">10</span>)
}
db.run(q2)
<span class="pl-c">// UPDATE Person USING TIMESTAMP 99 SET age = 10</span></pre></div>

<p><strong>usingTtl</strong></p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">q1</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].insert(_.age <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-c1">10</span>, _.name <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>John<span class="pl-pds">"</span></span>).usingTtl(<span class="pl-c1">11</span>)
}
db.run(q1)
<span class="pl-c">// INSERT INTO Person (age,name) VALUES (10, 'John') USING TTL 11</span>

<span class="pl-k">val</span> <span class="pl-en">q2</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].usingTtl(<span class="pl-c1">11</span>).update(_.age <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-c1">10</span>)
}
db.run(q2)
<span class="pl-c">// UPDATE Person USING TTL 11 SET age = 10</span>

<span class="pl-k">val</span> <span class="pl-en">q3</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].usingTtl(<span class="pl-c1">11</span>).filter(_.name <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>John<span class="pl-pds">"</span></span>).delete
}
db.run(q3)  
<span class="pl-c">// DELETE FROM Person USING TTL 11 WHERE name = 'John'</span></pre></div>

<p><strong>using</strong></p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">q1</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].insert(_.age <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-c1">10</span>, _.name <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>John<span class="pl-pds">"</span></span>).using(ts <span class="pl-k">=</span> <span class="pl-c1">99</span>, ttl <span class="pl-k">=</span> <span class="pl-c1">11</span>)
}
db.run(q1)
<span class="pl-c">// INSERT INTO Person (age,name) VALUES (10, 'John') USING TIMESTAMP 99 AND TTL 11</span>

<span class="pl-k">val</span> <span class="pl-en">q2</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].using(ts <span class="pl-k">=</span> <span class="pl-c1">99</span>, ttl <span class="pl-k">=</span> <span class="pl-c1">11</span>).update(_.age <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-c1">10</span>)
}
db.run(q2)
<span class="pl-c">// UPDATE Person USING TIMESTAMP 99 AND TTL 11 SET age = 10</span>

<span class="pl-k">val</span> <span class="pl-en">q3</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].using(ts <span class="pl-k">=</span> <span class="pl-c1">99</span>, ttl <span class="pl-k">=</span> <span class="pl-c1">11</span>).filter(_.name <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>John<span class="pl-pds">"</span></span>).delete
}
db.run(q3)
<span class="pl-c">// DELETE FROM Person USING TIMESTAMP 99 AND TTL 11 WHERE name = 'John'</span></pre></div>

<p><strong>ifCond</strong></p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">q1</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].update(_.age <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-c1">10</span>).ifCond(_.name <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>John<span class="pl-pds">"</span></span>)
}
db.run(q1)
<span class="pl-c">// UPDATE Person SET age = 10 IF name = 'John'</span>

<span class="pl-k">val</span> <span class="pl-en">q2</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].filter(_.name <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>John<span class="pl-pds">"</span></span>).delete.ifCond(_.age <span class="pl-k">==</span> <span class="pl-c1">10</span>)
}
db.run(q2)
<span class="pl-c">// DELETE FROM Person WHERE name = 'John' IF age = 10</span></pre></div>

<p><strong>delete column</strong></p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].map(p <span class="pl-k">=&gt;</span> p.age).delete
}
db.run(q)
<span class="pl-c">// DELETE p.age FROM Person</span></pre></div>

<h1>
<a id="dynamic-queries" class="anchor" href="#dynamic-queries" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Dynamic queries</h1>

<p>Quill's default operation mode is compile-time, but there are queries that have their structure defined only at runtime. Quill automatically falls back to runtime normalization and query generation if the query's structure is not static. Example:</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">import</span> <span class="pl-v">io.getquill.</span><span class="pl-v">_</span>

<span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">db</span> <span class="pl-k">=</span> source(<span class="pl-k">new</span> <span class="pl-en">MirrorSourceConfig</span>(<span class="pl-s"><span class="pl-pds">"</span>testSource<span class="pl-pds">"</span></span>))

<span class="pl-k">sealed</span> <span class="pl-k">trait</span> <span class="pl-en">QueryType</span>
<span class="pl-k">case</span> <span class="pl-k">object</span> <span class="pl-en">Minor</span> <span class="pl-k">extends</span> <span class="pl-e">QueryType</span>
<span class="pl-k">case</span> <span class="pl-k">object</span> <span class="pl-en">Senior</span> <span class="pl-k">extends</span> <span class="pl-e">QueryType</span>

<span class="pl-k">def</span> <span class="pl-en">people</span>(<span class="pl-v">t</span>: <span class="pl-en">QueryType</span>)<span class="pl-k">:</span> <span class="pl-en">Quoted</span>[<span class="pl-en">Query</span>[<span class="pl-en">Person</span>]] <span class="pl-k">=</span>
  t <span class="pl-k">match</span> {
    <span class="pl-k">case</span> <span class="pl-en">Minor</span> <span class="pl-k">=&gt;</span> quote {
      query[<span class="pl-en">Person</span>].filter(p <span class="pl-k">=&gt;</span> p.age <span class="pl-k">&lt;</span> <span class="pl-c1">18</span>)
    }
    <span class="pl-k">case</span> <span class="pl-en">Senior</span> <span class="pl-k">=&gt;</span> quote {
      query[<span class="pl-en">Person</span>].filter(p <span class="pl-k">=&gt;</span> p.age <span class="pl-k">&gt;</span> <span class="pl-c1">65</span>)
    }
  }

db.run(people(<span class="pl-en">Minor</span>)) 
<span class="pl-c">// SELECT p.id, p.name, p.age FROM Person p WHERE p.age &lt; 18</span>

db.run(people(<span class="pl-en">Senior</span>)) 
<span class="pl-c">// SELECT p.id, p.name, p.age FROM Person p WHERE p.age &gt; 65</span></pre></div>

<h1>
<a id="extending-quill" class="anchor" href="#extending-quill" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Extending quill</h1>

<h2>
<a id="infix" class="anchor" href="#infix" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Infix</h2>

<p>Infix is a very flexible mechanism to use non-supported features without having to use plain queries in the target language. It allows insertion of arbitrary strings within quotations.</p>

<p>For instance, quill doesn't support the <code>FOR UPDATE</code> SQL feature. It can still be used through infix and implicit classes:</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">implicit</span> <span class="pl-k">class</span> <span class="pl-en">ForUpdate</span>[<span class="pl-en">T</span>](<span class="pl-v">q</span>: <span class="pl-en">Query</span>[<span class="pl-en">T</span>]) {
  <span class="pl-k">def</span> <span class="pl-en">forUpdate</span> <span class="pl-k">=</span> quote(infix<span class="pl-s"><span class="pl-pds">"</span>$q FOR UPDATE<span class="pl-pds">"</span></span>.as[<span class="pl-en">Query</span>[<span class="pl-en">T</span>]])
}

<span class="pl-k">val</span> <span class="pl-en">a</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].filter(p <span class="pl-k">=&gt;</span> p.age <span class="pl-k">&lt;</span> <span class="pl-c1">18</span>).forUpdate
}

db.run(a)
<span class="pl-c">// SELECT p.id, p.name, p.age FROM (SELECT * FROM Person p WHERE p.age &lt; 18 FOR UPDATE) p</span></pre></div>

<p>The <code>forUpdate</code> quotation can be reused for multiple queries.</p>

<p>The same approach can be used for <code>RETURNING ID</code>:</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">implicit</span> <span class="pl-k">class</span> <span class="pl-en">ReturningId</span>[<span class="pl-en">T</span>](<span class="pl-v">a</span>: <span class="pl-en">Action</span>[<span class="pl-en">T</span>]) {
  <span class="pl-k">def</span> <span class="pl-en">returningId</span> <span class="pl-k">=</span> quote(infix<span class="pl-s"><span class="pl-pds">"</span>$a RETURNING ID<span class="pl-pds">"</span></span>.as[<span class="pl-en">Action</span>[<span class="pl-en">T</span>]])
}

<span class="pl-k">val</span> <span class="pl-en">a</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].insert(_.name <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>John<span class="pl-pds">"</span></span>, _.age <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-c1">21</span>).returningId
}

db.run(a)
<span class="pl-c">// INSERT INTO Person (name,age) VALUES ('John', 21) RETURNING ID</span></pre></div>

<p>A custom database function can also be used through infix:</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">myFunction</span> <span class="pl-k">=</span> quote {
  (<span class="pl-v">i</span>: <span class="pl-k">Int</span>) <span class="pl-k">=&gt;</span> infix<span class="pl-s"><span class="pl-pds">"</span>MY_FUNCTION($i)<span class="pl-pds">"</span></span>.as[<span class="pl-k">Int</span>]
}

<span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].map(p <span class="pl-k">=&gt;</span> myFunction(p.age))
}

db.run(q) 
<span class="pl-c">// SELECT MY_FUNCTION(p.age) FROM Person p</span></pre></div>

<h2>
<a id="custom-encoding" class="anchor" href="#custom-encoding" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Custom encoding</h2>

<p>Quill uses <code>Encoder</code>s to encode query inputs and <code>Decoder</code>s to read values returned by queries. The library provides a few built-in encodings and two mechanisms to define custom encodings: mapped encoding and raw encoding.</p>

<h3>
<a id="mapped-encoding" class="anchor" href="#mapped-encoding" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Mapped Encoding</h3>

<p>If the correspondent database type is already supported, use <code>mappedEncoding</code>. In this example, <code>String</code> is already supported by Quill and the <code>UUID</code> encoding from/to <code>String</code> is defined through mapped encoding:</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">import</span> <span class="pl-v">java.util.</span><span class="pl-v">UUID</span>

<span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">encodeUUID</span> <span class="pl-k">=</span> mappedEncoding[<span class="pl-en">UUID</span>, <span class="pl-k">String</span>](_.toString)
<span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">decodeUUID</span> <span class="pl-k">=</span> mappedEncoding[<span class="pl-k">String</span>, <span class="pl-en">UUID</span>](<span class="pl-en">UUID</span>.fromString(_))</pre></div>

<h3>
<a id="raw-encoding" class="anchor" href="#raw-encoding" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Raw Encoding</h3>

<p>If the database type is not supported by Quill, it is possible to provide "raw" encoders and decoders:</p>

<pre><code>import io.getquill.sources.mirror.Row

implicit val uuidEncoder = 
  db.encoder[UUID] {
    ??? // database-specific implementation
  }

implicit val uuidDecoder = 
  db.decoder[UUID] {
    ??? // database-specific implementation
  }
</code></pre>

<h3>
<a id="wrapped-types" class="anchor" href="#wrapped-types" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Wrapped types</h3>

<p>Quill also supports encoding of "wrapped types". Just extend the <code>WrappedValue</code> trait and Quill will automatically encode the underlying primitive type.</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">import</span> <span class="pl-v">io.getquill.sources.</span><span class="pl-v">_</span>

<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">UserId</span>(<span class="pl-v">value</span>: <span class="pl-k">Int</span>) <span class="pl-k">extends</span> <span class="pl-e">AnyVal</span> <span class="pl-k">with</span> <span class="pl-e">WrappedValue</span>[<span class="pl-k">Int</span>]
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">User</span>(<span class="pl-v">id</span>: <span class="pl-en">UserId</span>, <span class="pl-v">name</span>: <span class="pl-k">String</span>)

<span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  (<span class="pl-v">id</span>: <span class="pl-en">UserId</span>) <span class="pl-k">=&gt;</span> <span class="pl-k">for</span> {
    u <span class="pl-k">&lt;</span><span class="pl-k">-</span> query[<span class="pl-en">User</span>] <span class="pl-k">if</span> u.id <span class="pl-k">==</span> id
  } <span class="pl-k">yield</span> u
}
db.run(q)(<span class="pl-en">UserId</span>(<span class="pl-c1">1</span>))

<span class="pl-c">// SELECT u.id, u.name FROM User u WHERE (u.id = 1)</span></pre></div>

<h1>
<a id="sql-sources" class="anchor" href="#sql-sources" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>SQL Sources</h1>

<p>Sources represent the database and provide an execution interface for queries. Example:</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">import</span> <span class="pl-v">io.getquill.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">io.getquill.naming.</span><span class="pl-v">SnakeCase</span>
<span class="pl-k">import</span> <span class="pl-v">io.getquill.sources.sql.idiom.</span><span class="pl-v">MySQLDialect</span>

<span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">db</span> <span class="pl-k">=</span> source(<span class="pl-k">new</span> <span class="pl-en">JdbcSourceConfig</span>[<span class="pl-en">MySQLDialect</span>, <span class="pl-en">SnakeCase</span>](<span class="pl-s"><span class="pl-pds">"</span>db<span class="pl-pds">"</span></span>))</pre></div>

<h2>
<a id="dialect" class="anchor" href="#dialect" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Dialect</h2>

<p>The SQL dialect to be used by the source is defined by the first type parameter. Some source types are specific to a database and thus not require it.</p>

<p>Quill has three built-in dialects:</p>

<ul>
<li><code>io.getquill.sources.sql.idiom.H2Dialect</code></li>
<li><code>io.getquill.sources.sql.idiom.MySQLDialect</code></li>
<li><code>io.getquill.sources.sql.idiom.PostgresDialect</code></li>
</ul>

<h2>
<a id="naming-strategy" class="anchor" href="#naming-strategy" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Naming strategy</h2>

<p>The second type parameter defines the naming strategy to be used when translating identifiers (table and column names) to SQL. </p>

<table>
<thead>
<tr>
<th>strategy</th>
<th>example</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>io.getquill.naming.Literal</code></td>
<td>some_ident  -&gt; some_ident</td>
</tr>
<tr>
<td><code>io.getquill.naming.Escape</code></td>
<td>some_ident  -&gt; "some_ident"</td>
</tr>
<tr>
<td><code>io.getquill.naming.UpperCase</code></td>
<td>some_ident  -&gt; SOME_IDENT</td>
</tr>
<tr>
<td><code>io.getquill.naming.LowerCase</code></td>
<td>SOME_IDENT  -&gt; some_ident</td>
</tr>
<tr>
<td><code>io.getquill.naming.SnakeCase</code></td>
<td>someIdent   -&gt; some_ident</td>
</tr>
<tr>
<td><code>io.getquill.naming.CamelCase</code></td>
<td>some_ident  -&gt; someIdent</td>
</tr>
<tr>
<td><code>io.getquill.naming.MysqlEscape</code></td>
<td>some_ident  -&gt; `some_ident`</td>
</tr>
<tr>
<td><code>io.getquill.naming.PostgresEscape</code></td>
<td>$some_ident -&gt; $some_ident</td>
</tr>
</tbody>
</table>

<p>Multiple transformations can be defined using mixin. For instance, the naming strategy </p>

<p><code>SnakeCase with UpperCase</code></p>

<p>produces the following transformation:</p>

<p><code>someIdent -&gt; SOME_IDENT</code></p>

<p>The transformations are applied from left to right.</p>

<h2>
<a id="configuration" class="anchor" href="#configuration" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Configuration</h2>

<p>The string passed to the source configuration is used as the key to obtain configurations using the <a href="http://github.com/typesafehub/config">typesafe config</a> library.</p>

<p>Additionally, any member of a source configuration can be overriden. Example:</p>

<pre><code>import io.getquill._
import io.getquill.naming.SnakeCase
import io.getquill.sources.sql.idiom.MySQLDialect

lazy val db = source(new JdbcSourceConfig[MySQLDialect, SnakeCase]("db") {
  override def dataSource = ??? // create the datasource manually
})
</code></pre>

<h3>
<a id="quill-jdbc" class="anchor" href="#quill-jdbc" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>quill-jdbc</h3>

<p>Quill uses <a href="https://github.com/brettwooldridge/HikariCP">HikariCP</a> for connection pooling. Please refer to HikariCP's <a href="https://github.com/brettwooldridge/HikariCP#configuration-knobs-baby">documentation</a> for a detailed explanation of the available configurations.</p>

<p>Note that there are <code>dataSource</code> configurations, that go under <code>dataSource</code>, like <code>user</code> and <code>password</code>, but some pool settings may go under the root config, like <code>connectionTimeout</code>.</p>

<p><strong>MySQL</strong></p>

<p>sbt dependencies</p>

<pre><code>libraryDependencies ++= Seq(
  "mysql" % "mysql-connector-java" % "5.1.36",
  "io.getquill" %% "quill-jdbc" % "0.6.1-SNAPSHOT"
)
</code></pre>

<p>source definition</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">import</span> <span class="pl-v">io.getquill.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">io.getquill.naming.</span><span class="pl-v">SnakeCase</span>
<span class="pl-k">import</span> <span class="pl-v">io.getquill.sources.sql.idiom.</span><span class="pl-v">MySQLDialect</span>

<span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">db</span> <span class="pl-k">=</span> source(<span class="pl-k">new</span> <span class="pl-en">JdbcSourceConfig</span>[<span class="pl-en">MySQLDialect</span>, <span class="pl-en">SnakeCase</span>](<span class="pl-s"><span class="pl-pds">"</span>db<span class="pl-pds">"</span></span>))</pre></div>

<p>application.properties</p>

<pre><code>db.dataSourceClassName=com.mysql.jdbc.jdbc2.optional.MysqlDataSource
db.dataSource.url=jdbc:mysql://host/database
db.dataSource.user=root
db.dataSource.password=root
db.dataSource.cachePrepStmts=true
db.dataSource.prepStmtCacheSize=250
db.dataSource.prepStmtCacheSqlLimit=2048
db.connectionTimeout=30000
</code></pre>

<p><strong>Postgres</strong></p>

<p>sbt dependencies</p>

<pre><code>libraryDependencies ++= Seq(
  "org.postgresql" % "postgresql" % "9.4-1206-jdbc41",
  "io.getquill" %% "quill-jdbc" % "0.6.1-SNAPSHOT"
)
</code></pre>

<p>source definition</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">import</span> <span class="pl-v">io.getquill.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">io.getquill.naming.</span><span class="pl-v">SnakeCase</span>
<span class="pl-k">import</span> <span class="pl-v">io.getquill.sources.sql.idiom.</span><span class="pl-v">PostgresDialect</span>

<span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">db</span> <span class="pl-k">=</span> source(<span class="pl-k">new</span> <span class="pl-en">JdbcSourceConfig</span>[<span class="pl-en">PostgresDialect</span>, <span class="pl-en">SnakeCase</span>](<span class="pl-s"><span class="pl-pds">"</span>db<span class="pl-pds">"</span></span>))</pre></div>

<p>application.properties</p>

<pre><code>db.dataSourceClassName=org.postgresql.ds.PGSimpleDataSource
db.dataSource.user=root
db.dataSource.password=root
db.dataSource.databaseName=database
db.dataSource.portNumber=5432
db.dataSource.serverName=host
db.connectionTimeout=30000
</code></pre>

<h3>
<a id="quill-async" class="anchor" href="#quill-async" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>quill-async</h3>

<p><strong>MySQL Async</strong></p>

<p>sbt dependencies</p>

<pre><code>libraryDependencies ++= Seq(
  "io.getquill" %% "quill-async" % "0.6.1-SNAPSHOT"
)
</code></pre>

<p>source definition</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">import</span> <span class="pl-v">io.getquill.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">io.getquill.naming.</span><span class="pl-v">SnakeCase</span>

<span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">db</span> <span class="pl-k">=</span> source(<span class="pl-k">new</span> <span class="pl-en">MysqlAsyncSourceConfig</span>[<span class="pl-en">SnakeCase</span>](<span class="pl-s"><span class="pl-pds">"</span>db<span class="pl-pds">"</span></span>))</pre></div>

<p>application.properties</p>

<pre><code>db.host=host
db.port=3306
db.user=root
db.password=root
db.database=database
db.poolMaxQueueSize=4
db.poolMaxObjects=4
db.poolMaxIdle=999999999
db.poolValidationInterval=100
</code></pre>

<p><strong>Postgres Async</strong></p>

<p>sbt dependencies</p>

<pre><code>libraryDependencies ++= Seq(
  "io.getquill" %% "quill-async" % "0.6.1-SNAPSHOT"
)
</code></pre>

<p>source definition</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">import</span> <span class="pl-v">io.getquill.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">io.getquill.naming.</span><span class="pl-v">SnakeCase</span>

<span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">db</span> <span class="pl-k">=</span> source(<span class="pl-k">new</span> <span class="pl-en">PostgresAsyncSourceConfig</span>[<span class="pl-en">SnakeCase</span>](<span class="pl-s"><span class="pl-pds">"</span>db<span class="pl-pds">"</span></span>))</pre></div>

<p>application.properties</p>

<pre><code>db.host=host
db.port=5432
db.user=root
db.password=root
db.database=database
db.poolMaxQueueSize=4
db.poolMaxObjects=4
db.poolMaxIdle=999999999
db.poolValidationInterval=100
</code></pre>

<h3>
<a id="quill-finagle-mysql" class="anchor" href="#quill-finagle-mysql" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>quill-finagle-mysql</h3>

<p>sbt dependencies</p>

<pre><code>libraryDependencies ++= Seq(
  "io.getquill" %% "quill-finagle-mysql" % "0.6.1-SNAPSHOT"
)
</code></pre>

<p>source definition</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">import</span> <span class="pl-v">io.getquill.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">io.getquill.naming.</span><span class="pl-v">SnakeCase</span>

<span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">db</span> <span class="pl-k">=</span> source(<span class="pl-k">new</span> <span class="pl-en">FinagleMysqlSourceConfig</span>[<span class="pl-en">SnakeCase</span>](<span class="pl-s"><span class="pl-pds">"</span>db<span class="pl-pds">"</span></span>))</pre></div>

<p>application.properties</p>

<pre><code>db.dest=localhost:3306
db.user=root
db.password=root
db.database=database
db.pool.watermark.low=0
db.pool.watermark.high=10
db.pool.idleTime=5 # seconds
db.pool.bufferSize=0
db.pool.maxWaiters=2147483647
</code></pre>

<h1>
<a id="cassandra-sources" class="anchor" href="#cassandra-sources" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Cassandra Sources</h1>

<p>sbt dependencies</p>

<pre><code>libraryDependencies ++= Seq(
  "io.getquill" %% "quill-cassandra" % "0.6.1-SNAPSHOT"
)
</code></pre>

<p><strong>synchronous source</strong></p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">import</span> <span class="pl-v">io.getquill.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">io.getquill.naming.</span><span class="pl-v">SnakeCase</span>

<span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">db</span> <span class="pl-k">=</span> source(<span class="pl-k">new</span> <span class="pl-en">CassandraSyncSourceConfig</span>[<span class="pl-en">SnakeCase</span>](<span class="pl-s"><span class="pl-pds">"</span>db<span class="pl-pds">"</span></span>))</pre></div>

<p><strong>asynchronous source</strong></p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">import</span> <span class="pl-v">io.getquill.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">io.getquill.naming.</span><span class="pl-v">SnakeCase</span>

<span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">db</span> <span class="pl-k">=</span> source(<span class="pl-k">new</span> <span class="pl-en">CassandraAsyncSourceConfig</span>[<span class="pl-en">SnakeCase</span>](<span class="pl-s"><span class="pl-pds">"</span>db<span class="pl-pds">"</span></span>))</pre></div>

<p><strong>stream source</strong></p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">import</span> <span class="pl-v">io.getquill.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">io.getquill.naming.</span><span class="pl-v">SnakeCase</span>

<span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">db</span> <span class="pl-k">=</span> source(<span class="pl-k">new</span> <span class="pl-en">CassandraStreamSourceConfig</span>[<span class="pl-en">SnakeCase</span>](<span class="pl-s"><span class="pl-pds">"</span>db<span class="pl-pds">"</span></span>))</pre></div>

<p>The configurations are set using runtime reflection on the <a href="https://docs.datastax.com/en/drivers/java/2.1/com/datastax/driver/core/Cluster.Builder.html"><code>Cluster.builder</code></a> instance. It is possible to set nested structures like <code>queryOptions.consistencyLevel</code>, use enum values like <code>LOCAL_QUORUM</code>, and set multiple parameters like in <code>credentials</code>.</p>

<p>application.properties</p>

<pre><code>db.keyspace=quill_test
db.preparedStatementCacheSize=1000
db.session.contactPoint=127.0.0.1
db.session.queryOptions.consistencyLevel=LOCAL_QUORUM
db.session.withoutMetrics=true
db.session.withoutJMXReporting=false
db.session.credentials.0=root
db.session.credentials.1=pass
db.session.maxSchemaAgreementWaitSeconds=1
db.session.addressTranslater=com.datastax.driver.core.policies.IdentityTranslater
</code></pre>

<h1>
<a id="templates" class="anchor" href="#templates" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Templates</h1>

<p>In order to quickly start with Quill, we have setup some template projects:</p>

<ul>
<li><a href="https://github.com/getquill/play-quill-jdbc">Play Framework with Quill JDBC</a></li>
</ul>

<h1>
<a id="slick-comparison" class="anchor" href="#slick-comparison" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Slick comparison</h1>

<p>Please refer to <a href="https://github.com/getquill/quill/blob/master/SLICK.md">SLICK.md</a> for a detailed comparison between Quill and Slick.</p>

<h1>
<a id="cassandra-libraries-comparison" class="anchor" href="#cassandra-libraries-comparison" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Cassandra libraries comparison</h1>

<p>Please refer to <a href="https://github.com/getquill/quill/blob/master/CASSANDRA.md">CASSANDRA.md</a> for a detailed comparison between Quill and other main alternatives for interaction with Cassandra in Scala.</p>

<h1>
<a id="maintainers" class="anchor" href="#maintainers" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Maintainers</h1>

<ul>
<li><a href="https://github.com/fwbrasil" class="user-mention">@fwbrasil</a></li>
<li><a href="https://github.com/godenji" class="user-mention">@godenji</a></li>
<li><a href="https://github.com/gustavoamigo" class="user-mention">@gustavoamigo</a></li>
<li><a href="https://github.com/jilen" class="user-mention">@jilen</a></li>
<li><a href="https://github.com/lvicentesanchez" class="user-mention">@lvicentesanchez</a></li>
</ul>

<p>You can notify all maintainers using the handle <code>@getquill/maintainers</code>.</p>

<h1>
<a id="acknowledgments" class="anchor" href="#acknowledgments" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Acknowledgments</h1>

<p>The project was created having Philip Wadler's talk <a href="http://www.infoq.com/presentations/theory-language-integrated-query">"A practical theory of language-integrated query"</a> as its initial inspiration. The development was heavily influenced by the following papers:</p>

<ul>
<li><a href="http://homepages.inf.ed.ac.uk/slindley/papers/practical-theory-of-linq.pdf">A Practical Theory of Language-Integrated Query</a></li>
<li><a href="http://homepages.inf.ed.ac.uk/wadler/papers/qdsl/qdsl.pdf">Everything old is new again: Quoted Domain Specific Languages</a></li>
<li><a href="http://db.inf.uni-tuebingen.de/staticfiles/publications/the-flatter-the-better.pdf">The Flatter, the Better</a></li>
</ul>

<h1>
<a id="code-of-conduct" class="anchor" href="#code-of-conduct" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Code of Conduct</h1>

<p>Please note that this project is released with a Contributor Code of Conduct. By participating in this project you agree to abide by its terms. See <a href="https://github.com/getquill/quill/blob/master/CODE_OF_CONDUCT.md">CODE_OF_CONDUCT.md</a> for details.</p>

<h1>
<a id="license" class="anchor" href="#license" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>License</h1>

<p>See the <a href="https://github.com/getquill/quill/blob/master/LICENSE.txt">LICENSE</a> file for details.</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Quill maintained by <a href="https://github.com/getquill">getquill</a></p>
        <p>Published with <a href="https://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-65451450-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>


  </body>
</html>
